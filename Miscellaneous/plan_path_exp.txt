
- on doit reperer au moment de la dequotation, les etoiles qui sont valides
 de celles qui etaient entre quotes ou escaped par un backslash.
 	-> le seul moyen c'est d'avoir une liste chainee qui contient des ints, qui
	 seraient la position des etoiles valides dans la grande string.
	 tout ca juste au cas ou un gogole decide de mettre une asterix dans un nom	
	 de fichier.
- on doit egalement distinguer des / qui separent les dossiers, des \/ qui font
	partie des characteres du nom d'un fichier...


TODO LIST:
	1/ parcourir la liste chainee, entrer dans sous fonction avec token. 	OK
	2/ les nouveaux paths doivent aller dans la liste chainee de tokens,
		il faut la declarer mais la laisser vide au debut.
	3/ creer une structure et sa fonction de base.
		t_token *token_duplicated (contient toutes les infos, la string et les
				portions de string protegees). OU juste un pointer?
		t_list *nouveaux_paths. ( NULL au debut, si a la fin c'est vide on
				saura qu'il n'y a eu aucun match, donc utiliser le token de base).
		is_filename, si on le met la, ca permettra de tres vite detecter une
			erreur de ambiguous redirect, ne pas attendre de tout parcourir!
		int first match (initialement zero, puis mis a un au premier match.)
				permet de savoir si on a eu au moins un match.

		t_list *splited_path, une liste chainee dans laquelle on a tous les
			morceaux du paths.(le separateur etait le '/') mais aussi une liste
			chainee de ints. qui sont les positions des etoiles que l'on
			considere wild cards.
	4/ fonction qui split une string dans une liste chainee plutot que dans
		un tableau a 2 dimensions. voir plus haut: t_list *splitted_path.
		1/ il faut collapser tout les '/' consecutifs. (sauf le premier si il
		vient apre un '\') et ce apres avoir skipper les quotes qui peuvent
		etre entre! doubles ou simples, pareil!
		nb: si des quotes doubles sont ouvertes. il peut y avoir des quotes
		simples a l'interieur et vice versa.

		2/ faire un split qui va fracturer le token en plusieurs tokens
			dans une liste chainee. a chaque fois on veut savoir si
			le morceau de string est la suite d'un morceau protege par des
			quotes donc il nous faut une structure:
				char *path_part
				char protected (avec le character de protection) si il vaut
					autre que zero, on sait que on commencera la string a
					l'interieur de cette protection.
				t_list *int_positions. la position des etoiles valides.
		3/ repasser dans chaque maillon de la liste chainee, et pour chaque
		string, tout dequoter, et noter la position des etoiles valides dans la
		liste chainee des ints.
		NB: la dequotation dans le pathname expansion, ne prend pas en compte
		le fait que le token soit proteger (provienne d'un word expansion...)
		nb: on enleve les quotes cat on doit avoir une string la plus clean possible
		pour la comparaison avec les noms de dossiers et fichiers.
	5/ entrer dans une fonction qui a en arguments la super structure qui
		contient tout. et un char * qui serait le debut de la string valide
		(voir recursion).
		Cette derniere va lancer une fonction de recurcion, et recuperer des
		messages d'erreur, et voir point 7 pour differentes actions.
	6/ fonction de recursion, qui essaye de matcher avec le premier morceau
	de nom d'un fichier/dossier. en argument, un t_list *path_parts, et une
	string qui est un malloc de la recursion precedente, et un boolean qui
	vaudra 1 seulement la premiere fois "first_recursion".
	peut etre il faudra trouver un moyen de distinguer nom de ficher (fin de liste
			chainee), des noms de dossiers.
	si on est dans la premiere recursion: (first_recursion), on mettre que le
	nom du fichier/dossier dans le path_name, et pas le '/' qui va devant.
		nb: le premier path_parts est une string vide:
		il faut ouvrir root, et partir du principe qu'il y a match. donc
		recursion... mais ne pas mettre le '/' a ce stade.
		NB2: on ne serait jamais rentre dans ce bout de code si tout etait vide
		car on l'aurait detecte bien avant.
		(au niveau de fonction pathname_is_expandable())
	si on est pas dans la premiere recursion, il faut append le '/', puis le
	nom de fichier/dossier.
	si on arrive sur un path_parts qui contient une string vide. on est juste
	avant la fin, il faut juste append le '/'. OK
	si on arrive sur un path_parts NULL, la on sait que on a valider le nom d'un
	fichier ->
		checker si le boolean first_match est a zero. l'activer.
		si il est deja a un, checker si le is_filename n'est pas activer..
		copier la string totale dans un nouveau token, qui va venir s'ajouter
		a la t_list *nouveaux_paths.
	dans toutes les recursions, il faudra free les mallocs faits pour append
	des nouveaux bouts de strings.

	7/ a la fin si on a une liste chainee de *nouveaux_paths non nuls, on remplace le
	token actuel par la nouvelle liste chainee, in situ: utiliser
	word_expand_replace() par exemple.
	si non, zero matchs, donc on va prendre le token initial, et le faire
	passer par la fonction classique de unquoting (qui regarde les portions de
	string protegees etc.)
	si erreurs, agir en consequences.


