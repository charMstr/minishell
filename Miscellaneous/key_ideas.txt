-------------------------------------------------------------------------------
--questions--
-------------------------------------------------------------------------------
- should the child or the parent be on the left side of the pipe!?

- recheck the fildescriptor table, etc and the per processes structures.

- do i need to have a blocking or non blocking pipe? in every specific cases?
-------------------------------------------------------------------------------
--key concepts-- 
-------------------------------------------------------------------------------
- when the pipe has only one end that is closed (either the source - write end,
or the drain - the read end) it is considered "widowed"

- need to use pipe() before using fork()

- need to close the read in the left side of the pipe, same goes for the right
side (left side -> writing, right side -> reading).

- redirection de la sortie standard dans un fichier, ou bien un pipe...
il faudrait:
	1) sauvegarder le stdout dans "old_out" grace a un dup() par exemple.
	2) close(1);
	3) "new_out" sera le resultat de open sur le fichier a creer/append...
	4) ecrire dans new_out.
	5) close new_out (cela devrait closer le fd 1)
	6) new_out = dup(old_out); on reassocie la valeur fd=1 a stdout.
	7) close(old_out) //on en a finit avec le stockage temporaire de stdout.

- I/O on pipes and FIFOs (kindof the same, wo keep in mind while searching...)
The only difference between pipes and FIFOs is the manner in which they are
created and opened. Once these tasks have been accomplished, I/O on pipes and
FIFOs has exactly the same semantics.

- The simplest way to handle SIGPIPE from your own C code if you don't want it
to die when writing to a fifo, would be to call signal(SIGPIPE, SIG_IGN); and
handle it by checking for errno EPIPE after each write() instead.

- SIGNALS:
	Ctrl+C is used to send a SIGINT signal, which cancels or terminates the
	currently running program.
	
	Crtl+D:
	note: "set -o ignoreeof" in bash will cancel further tries to use ctrl+D
	
	ctrl-\:
	note: meme resultat que si on fait "ctrl+4"

	Shells handle all common signals, so that if you type ^\ in a shell, you
	don't kill your session, you just get a new prompt, same as ^C.

	If the process has previously registered a signal handler, that routine is
	executed. Otherwise, the default signal handler is executed.
	nb: "signal handler" = "trap"

	Unless a process takes special action in advance, most signals are fatal; 
	that is, the default action a process will perform upon receiving a signal 
	is an immediate exit. (Exceptions: SIGCHLD is ignored by default, SIGSTOP 
	pauses the process, and SIGCONT resumes the process.) Some signals (such as
	SIGQUIT) also cause a process to leave a core file, in addition to exiting.

	signal(SIGINT, SIG_IGN);
	-> this allows us to ignore the ctrl+c (this will be used in the main shell
	process). then in the childs we will have tod do:
		-> signal(SIGINT, SIG_DFL)
		becuase the child inherits the current sgnal configurations (also known
		as the signal dispositions).

	note: Each process has an attribute called the process signal mask which 
	is maintained by the kernel.
		-> if we call a signal handler (tied to SIGINT for example), then if we
		try to trigger it once more, it wont be interrupted, then next SIGINT
		is queud though
		-> we can interrupt the signal with another sort of signal. for example
		SIGINT can be interrupted by SIGQUIT... keep in mind...

- PIPE
	(source wiki):
	In most Unix-like systems, all processes of a pipeline are started at the
	same time, with their streams appropriately connected, and managed by the
	scheduler together with all other processes running on the machine. ...
	In Linux, the size of the buffer is 65,536 bytes (64KiB).

- WRITE
	aschtung /!\: ecriture bloquante par default tant quon a pas ecrit n
	characteres dans la formule: write(p[1], buf, n);
	cas apparent quand on essaye d'ecrire quelque chose de plus gros que la
	macro PIPE_BUF

/* FINDINGS:
   if we want to do the good old cat /dev/random | head -1 and get the result
   0 when we do a echo $?. the only chance is to execute it in a way that the
   child process is on the left side(writting in the pipe).
   As we call the execve() the signal handler we set for the  SIGCHLD is
   completely innefective. when the parent is on the left (writing side of the
   pipe), as the right side finishes (head -1), the left side continues, then
   abort since it tried to write in a pipe that was closed (echo $? => 141).
   and there is nothing we can do about it. except for puting the parent
   process on the right. when the child keeps on writing, it just dies, but on
   on the parent side, we had a ending process.
	note: double checked: if you try to read from a closed fd, read will just
	returN 0.

	note: if the process on the left fails. it is notified by perror on the
	stderr. but the echo $? still depends on the exit of the most right process
	of the pipe stream!
*/



-------------------------------------------------------------------------------
--SOLUTIONS
-------------------------------------------------------------------------------
0) when using thing such as execve, we cannot free any memory.				OK
therefore the parsing and mallocs will all occur in the shell main process.
Or there is a fork dedicated jsut to run this execve.

1) SET the parent process to the right.										OK
if the right most process is done: the left parts are going to abort when tring
to write  with the good old SIGPIP error.
after a parsing, we will have to spawn childs from the right. first fork will
have as a child the most right command from the potential piped commands.

2) if the left processes finishes early, or abort...						???
we will have to cascade that all the way to the right most process to tell him
to quit ??
 --> yes, because we cannot rely on the return from read. if read returns zero,
 it doesnt mean everything worked fine, it just means the pipe is empty, or
 closed....
 --> well actually no. the exit status (get it withc echo $?) depends only from
 a successfull very last command(the one on the right end of the pipe).

